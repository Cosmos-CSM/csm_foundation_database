using System.Collections;
using System.Collections.ObjectModel;
using System.Reflection;
using System.Text.Json;

using CSM_Foundation.Core;
using CSM_Foundation.Database;
using CSM_Foundation.Server;

using CSM_Foundation_Database.Entity;
using CSM_Foundation_Database.Models;

using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.ChangeTracking;
using Microsoft.VisualBasic;

namespace CSM_Foundation_Database.Utilitites;
public class DatabaseUtilities {
    const string DirectoryName = ".Connection";
    const string QualityPrefix = "quality";
    const string DevelopmentPrefix = "development";
    const string ProductionPrefix = "production";


    /// <summary>
    ///     Connection file name template for Quality environment variable.
    /// </summary>
    const string Q_CONNTION_TMPLATE = "Q_{0}.Connection";

    /// <summary>
    ///     Fetches and loads through IO functionallities for private file based secret
    ///     connection properties for DataDatabasess connections handlers. 
    ///     Then build it and validate it to generate a Model.
    ///     
    ///     RECOMMENDED: Check the parameter documentation to ensure the correct use.
    /// </summary>
    /// <param name="cp"> 
    ///     Automatically gets the path of the method caller through execution-time assemblies access
    ///     attribute decorator, this is correctly calculated when the method is called
    ///     directly in the DataDatabases context class that is generated by the EF CLI tools when 
    ///     migrated a database configuration, otherwise can struggle with the correct project 
    ///     file leveling generation. 
    ///     In that kind of cases this parameter can be overwritten by the caller to inject
    ///     the correct dataDatabases project root path.
    /// </param>
    /// <returns>
    ///     <see cref="ConnectionOptions"/>: The dataDatabases connection properties gathered and retrieved from the found private properties file.
    /// </returns>
    /// <exception cref="Exception">
    ///     When something gone wrong during the IO connection properties gather operation.
    /// </exception>
    public static ConnectionOptions Retrieve(string DatabaseSign) {
        string wd = Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location)!;

        string prefix = ServerUtils.Environment switch {
            ServerEnvironments.development => DevelopmentPrefix,
            ServerEnvironments.quality => QualityPrefix,
            ServerEnvironments.production => ProductionPrefix,
            _ => DevelopmentPrefix,
        };
        string fn = $"{prefix}.connection.json";

        if (wd is null) {
            throw new ArgumentNullException(wd);
        }

        string tp = $"{wd}\\{DatabaseSign.ToUpper()}{DirectoryName}";
        string? cpd = Directory.GetDirectories(wd)
            .Where(i => i == tp)
            .FirstOrDefault()
            ?? throw new DirectoryNotFoundException($"{tp} not found in the system");

        string tfn = $"{tp}\\{fn}";

        string[] cfs = Directory.GetFiles(cpd);
        string cpfi = cfs
            .Where(i => i == tfn)
            .FirstOrDefault()
            ?? throw new FileNotFoundException($"{tfn} not found in the system");

        using FileStream pfs = new(cpfi, FileMode.Open, FileAccess.Read, FileShare.Read);
        ConnectionOptions? m = JsonSerializer.Deserialize<ConnectionOptions>(pfs);
        pfs.Dispose();

        return m is null ? throw new Exception() : m;
    }

    /// <summary>
    ///     Sanitizes the entity relations to ensure that the relations are correctly tracked from the database and avoid the creation of relation entities wrongly given through the main entity.
    /// </summary>
    /// <typeparam name="TEntity">
    ///     Type of the Main Entity to be sanitized.
    /// </typeparam>
    /// <param name="database">
    ///     Database context handler for Entity to be sanitized.
    /// </param>
    /// <param name="entity">
    ///     Entity instance to be sanitized
    /// </param>
    /// <returns></returns>
    /// <exception cref="InvalidOperationException">
    ///     Thrown when the dbSet couldn't be found for the relation entity.
    ///     Thrown when a relation Entity is being tried to be created automatically.
    ///     Thrown when the relation isn´t a IEntity implementation neither a Collection of IEntity.
    /// </exception>
    /// <exception cref="Exception">
    ///     Thrown when the relation entity couldn't be found in the database.
    /// </exception>
    public static TEntity SanitizeEntity<TEntity>(DbContext database, TEntity entity) {

        
        IQueryable<IEntity> GetDbSet(Type entityType) {
            object objectDbSet = typeof(DbContext)
                .GetMethods()
                .Where(
                    m => m.Name == nameof(DbContext.Set) && m.IsGenericMethod && m.GetGenericArguments().Length == 1
                )
                .FirstOrDefault()?
                .MakeGenericMethod(entityType)
                .Invoke(database, null)
                ?? throw new XSystem($"DbContext({database.GetType().Name}) doesn´t have the neccesary DbSet({entityType.Name}) method", null);

            return (IQueryable<IEntity>)objectDbSet;
        }

        if (entity == null) {
            return entity;
        }

        IEnumerable<PropertyInfo> relationProperties = entity
            .GetType()
            .GetProperties()
            .Where(
                (pi) => pi.GetCustomAttribute<RelationAttribute>() != null
            );

        foreach (PropertyInfo relationProperty in relationProperties) {
            Type relationType = relationProperty.PropertyType;
            object? relationValue = relationProperty.GetValue(entity);

            if (relationValue is null) {
                continue;
            }

            bool isCollection = relationValue is IEnumerable<IEntity>;
            bool isEntity = relationValue is IEntity;

            if (!isEntity && !isCollection) {
                throw new XSystem($"Entity relation integrity problem, relation has [Relation] attribute but is not a IEnumerable<IEntity> neither IEntity assignable relation", null);
            }

            if (isEntity) {
                IEntity relEntity = (IEntity)relationValue;

                if (relEntity.Id <= 0) {
                    throw new XSystem($"Dependencies aren't allowed to be created on main Entity creation", null);
                }

                IQueryable<IEntity> dbSet = GetDbSet(relEntity.GetType());

                IEntity dbRelEntity = dbSet.Where(
                        entity => entity.Id == relEntity.Id
                    )
                    .FirstOrDefault()
                    ?? throw new XSystem($"Couldn't find relation entity ({relEntity.GetType().Name})[{relEntity.Id}]", null);

                relationProperty.SetValue(entity, dbRelEntity);
                EntityEntry entityEntry = database.Entry(dbRelEntity);
                if (entityEntry.State == EntityState.Detached) {
                    entityEntry.State = EntityState.Unchanged;
                }
            } else { 
                /// --> At this point we already know it's a collection relation.
                IEnumerable<IEntity> relCollection = (IEnumerable<IEntity>)relationValue;
                if(!relCollection.Any())
                    continue;

                IEnumerable<object> dbRelCollection = [];
                Type relEntityType = relCollection.First().GetType();
                IQueryable<IEntity> dbSet = GetDbSet(relEntityType);

                foreach (IEntity relEntity in relCollection) {

                    IEntity dbRelEntity = dbSet.Where(
                            entity => entity.Id == relEntity.Id
                        )
                        .FirstOrDefault()
                        ?? throw new XSystem($"Couldn't find relation entity ({relEntity.GetType().Name})[{relEntity.Id}]", null); ;

                    EntityEntry relEntityEntry = database.Entry(dbRelEntity);
                    if(relEntityEntry.State == EntityState.Detached) {
                        relEntityEntry.State = EntityState.Unchanged;
                    }

                    dbRelCollection = dbRelCollection.Append(dbRelEntity);
                }

                object castedCollection = typeof(Enumerable)
                    .GetMethod("Cast")?
                    .MakeGenericMethod(relEntityType)
                    .Invoke(null, 
                        [ 
                            dbRelCollection 
                        ]
                    ) 
                    ?? throw new XSystem($"Unable to cast IEntity to Entity type object", null);

                castedCollection = typeof(Enumerable)
                    .GetMethod("ToList")?
                    .MakeGenericMethod(relEntityType)
                    .Invoke(
                        null,
                        [
                            castedCollection
                        ]
                    )
                    ?? throw new XSystem("Unable to convert entity collection", null);

                relationProperty.SetValue(entity, castedCollection);
            }
        }
        return entity;
    }

    /// <summary>
    ///     Creates a new <typeparamref name="TDatabase"/> instance for quality/testing purposes, getting the connection options file from 
    ///     the run settings environment variables required.
    /// </summary>
    /// <typeparam name="TDatabase">
    ///     Database context handler type.
    /// </typeparam>
    /// <param name="sign">
    ///     Specific database connection sign for identification.
    /// </param>
    /// <param name="options">
    ///     Specific EF native configuration options for the instance created.
    /// </param>
    /// <returns>
    ///     An instance of <typeparamref name="TDatabase"/>.
    /// </returns>
    /// <exception cref="Exception">
    ///     <list type="bullet">
    ///         <item> Thrown when envrionment variable couldn't be found </item>
    ///         <item> Thrown when the file specified doesn't match the Connection Options format </item>
    ///         <item> Thrown when the Activator couldn't create correctly the instance of the database context </item>
    ///     </list>
    /// </exception>
    public static TDatabase Q_Construct<TDatabase>(string sign, DbContextOptions? options = null)
        where TDatabase : BDatabase<TDatabase> {

        string connectionVariable = string.Format(Q_CONNTION_TMPLATE, sign);

        string connectionPath = Environment.GetEnvironmentVariable(connectionVariable)
            ?? throw new Exception($"Unable to run tests for {typeof(TDatabase).FullName}, due to couldn't be found Connection file path (Make sure the environment variable [{connectionVariable}] is set or configured at the .runsettings tests context)");

        using FileStream fileReader = new(connectionPath, FileMode.Open, FileAccess.Read);

        ConnectionOptions connection = JsonSerializer.Deserialize<ConnectionOptions>(fileReader)
            ?? throw new Exception($"File ({connectionPath}) doesn't contain the correct format for (ConnectionOptions)");



        TDatabase? Database;
        if (options == null) {
            Database = (TDatabase?)Activator.CreateInstance(typeof(TDatabase), connection);
        } else {
            Database = (TDatabase?)Activator.CreateInstance(typeof(TDatabase), connection, options);
        }
        return Database ?? throw new Exception($"Unable to create ({typeof(TDatabase).FullName}) instance with the ConnectionOptions[{connectionPath}]"); ;
    }
}
